<?R
	source("conf.R") 
	c_header();
	
	source("lib/feq.R")
	source("lib/boundary.R")

	U = as.matrix(Density[Density$group=='f',c("dx","dy")])
  u = PV(c("ux","uy"))
  rho = PV("rho")
	J = PV("J",c("x","y"))

	EQ = MRT_eq(U, ortogonal=FALSE)
  wi = subst(EQ$Req, Jx=0, Jy=0, Jz=0)
  wi = subst(wi, rho=1)
  wi = gapply(wi,function(x) x$.M, simplify=TRUE)
  wi = wi %*% solve(EQ$mat)
	wi = as.vector(wi)

	W = solve(EQ$mat) %*% diag(1/wi) %*% solve(t(EQ$mat))
	i = rev(1:nrow(W))
	H = chol(W[i,i])[i,i]
	H = H * c(1,sqrt(3)/3,sqrt(3)/3,sqrt(2),sqrt(2),1,sqrt(6)/3,sqrt(6)/3,2)
	B = EQ$mat %*% t(H)

	EQ = MRT_eq(U, rho, J, mat=B)
	
  f = PV(Density[Density$group=='f',"name"])
  c = PV(Density[Density$group=='c',"name"])

  if ( any( DensityAll$group=="BC" ) ) {
    BC_Velocity=PV(c('BC[0]', 'BC[1]'))
  } else {
    BC_Velocity=PV(c('VelocityX', 'VelocityY'))
  }
?>

#define pi 3.141592653589793116

CudaDeviceFunction void SetEquilibrum(real_t rho, real_t Jx, real_t Jy)
{
  <?R
	feq = EQ$Req %*% solve(EQ$mat)
	C(f, EQ$feq)
  ?>
  <?R if ( any( DensityAll$group=="BC" ) ) { ?>
   if ( IamBOUNDARY ) {
       BC[0] = Jx / rho;
       BC[1] = Jy / rho;
   } else {
       BC[0] = 0;
       BC[1] = 0;
   }
  <?R } ?>
}

CudaDeviceFunction void Init() {
	real_t rho, C;
  rho = (1+Pressure*3);
  vector_t u;
	u.x = VelocityX;
  u.y = VelocityY;
  C = C_init;
  <?R if ( any( DensityAll$group=="BC" ) ) { ?>
    if (IamWall){
        rho = 1;
        u.x = 0;
        u.y = 0;
    }
  <?R } ?>
	SetEquilibrum(
		rho,
    rho*u.x,
    rho*u.y
	);

  c[0] = ( 2. + ( -u.y*u.y - u.x*u.x )*3. )*C*2./9.;
  c[1] = ( 2. + ( -u.y*u.y + ( 1 + u.x )*u.x*2. )*3. )*C/18.;
  c[2] = ( 2. + ( -u.x*u.x + ( 1 + u.y )*u.y*2. )*3. )*C/18.;
  c[3] = ( 2. + ( -u.y*u.y + ( -1 + u.x )*u.x*2. )*3. )*C/18.;
  c[4] = ( 2. + ( -u.x*u.x + ( -1 + u.y )*u.y*2. )*3. )*C/18.;
  c[5] = ( 1. + ( ( 1 + u.y )*u.y + ( 1 + u.x + u.y*3. )*u.x )*3. )*C/36.;
  c[6] = ( 1. + ( ( 1 + u.y )*u.y + ( -1 + u.x - u.y*3. )*u.x )*3. )*C/36.;
  c[7] = ( 1. + ( ( -1 + u.y )*u.y + ( -1 + u.x + u.y*3. )*u.x )*3. )*C/36.;
  c[8] = ( 1. + ( ( -1 + u.y )*u.y + ( 1 + u.x - u.y*3. )*u.x )*3. )*C/36.;

  h_Z = 1.;
}

CudaDeviceFunction void InitFromFields() {
  h_Z = Height;
}

CudaDeviceFunction void Run() {
  switch (NodeType & NODE_BOUNDARY) {
	  case NODE_Solid:
	  case NODE_Wall:
      BounceBack();
      break;
    case NODE_EVelocity:
      EVelocity();
      break;
    case NODE_WPressure:
      WPressure();
      break;
    case NODE_WVelocity:
      WVelocity();
      break;
    case NODE_EPressure:
      EPressure();
      break;
    case NODE_NVelocity:
      NVelocity();
      break;
    case NODE_SVelocity:
      SVelocity();
      break;
    case NODE_NSymmetry:
      NSymmetry();
      break;
    case NODE_SSymmetry:
      SSymmetry();
      break;
  }
  switch (NodeType & NODE_COLLISION)
  {
    case NODE_MRT:
      CollisionMRT();
      ConcentrationCollisionBGK();
      ConcentrationSourceAndEvolveHZ();
      break;
  }
}

CudaDeviceFunction void BounceBack()
{
    <?R if ( any( DensityAll$group=="BC" ) ) { ?>

    <?R C(PV('real_t temp'), sum(f)) ?>

    if ( temp !=  1+Pressure*3 ) {
        <?R C(PV(c('BC[0]', 'BC[1]')), 2.* f %*% U); ?>
    } else {
        <?R C(PV(c('BC[0]', 'BC[1]')), c(0,0) ); ?>
    }
    <?R } ?>
    <?R FullBounceBack() ?>
}

CudaDeviceFunction void EVelocity()
{
  <?R ZouHeRewrite(EQ, f, c(1, 0), "velocity", BC_Velocity) ?>
}

CudaDeviceFunction void WPressure()
{
  <?R ZouHeRewrite(EQ, f, c(-1, 0), "pressure") ?>
}

CudaDeviceFunction void WVelocity()
{
  <?R ZouHeRewrite(EQ, f, c(-1, 0), "velocity", BC_Velocity) ?>
  real_t C = 6.*( C_inlet - (c[0] + c[2] + c[4] + c[3] + c[7] + c[6]) );
	c[1] = (1./9.) * C;
	c[5] = (1./36.) * C;
	c[8] = (1./36.) * C;
}

CudaDeviceFunction void EPressure()
{
  <?R ZouHeRewrite(EQ, f, c(1, 0), "pressure") ?>
  real_t C = 6.*( C_outlet - ( c[0] + c[2] + c[4] + c[1] + c[5] + c[8] ) );
	c[3] = (1./ 9.) * C;
	c[7] = (1./36.) * C;
	c[6] = (1./36.) * C;
}

CudaDeviceFunction void NVelocity()
{
  <?R ZouHeRewrite(EQ, f, c(0,1), "velocity", BC_Velocity) ?>
}

CudaDeviceFunction void SVelocity()
{
  <?R ZouHeRewrite(EQ, f, c(0, -1), "velocity", BC_Velocity) ?>
}

CudaDeviceFunction void NSymmetry()
{
  <?R Symmetry(2,-1,'f') ?>
}

CudaDeviceFunction void SSymmetry()
{
  <?R Symmetry(2,1,'f') ?>
}

CudaDeviceFunction void CollisionMRT()
{
  <?R
	MI = solve(EQ$mat)
	P = MI %*% diag(1/wi) %*% t(MI)

	R = PV("R", 1:nrow(U)-1);
	selR = EQ$order > 1
	R[!selR] = EQ$Req[!selR]
  ?>
  
	real_t <?R C(R,sep=",") ?>;
  real_t Usq=0;

  <?R
  S=PV("S",1:nrow(U)-1);
	S[EQ$order == 2] = PV("S2")
	S[EQ$order == 3] = PV("S3")
 	S[EQ$order == 4] = PV("S4")   
	C(R, f %*% EQ$mat);
	C( R[selR], (R - EQ$Req)[selR]);
	C( R[selR], (R * S)[selR]);
  ?>
  real_t dJx =  GravitationX*rho ;
  real_t dJy =  GravitationY*rho ; 

  real_t nu = -(S2 + 1)/(6*S2 - 6) ;
  real_t K = rho * 12. * nu / h_Z / h_Z;
    
  Jx = Jx + dJx - K*(Jx+dJx*0.5)/(1. + 0.5 * K) / rho;
  Jy = Jy + dJy - K*(Jy+dJy*0.5)/(1. + 0.5 * K) / rho;   

  <?R
  C(R[selR], (R + EQ$Req)[selR]);
	C(f, R %*% solve(EQ$mat), float=F);
  ?>
}

CudaDeviceFunction void ConcentrationCollisionBGK() {
	real_t C = getC();
  real_t d = getRho();
	vector_t u;
	u.x =  (f[8]-f[7]-f[6]+f[5]-f[3]+f[1])/d;
	u.y = (-f[8]-f[7]+f[6]+f[5]-f[4]+f[2])/d;

	real_t c_eq[9];
  c_eq[0] = ( 2. + ( -u.y*u.y - u.x*u.x )*3. )*C*2./9.;
  c_eq[1] = ( 2. + ( -u.y*u.y + ( 1 + u.x )*u.x*2. )*3. )*C/18.;
  c_eq[2] = ( 2. + ( -u.x*u.x + ( 1 + u.y )*u.y*2. )*3. )*C/18.;
  c_eq[3] = ( 2. + ( -u.y*u.y + ( -1 + u.x )*u.x*2. )*3. )*C/18.;
  c_eq[4] = ( 2. + ( -u.x*u.x + ( -1 + u.y )*u.y*2. )*3. )*C/18.;
  c_eq[5] = ( 1. + ( ( 1 + u.y )*u.y + ( 1 + u.x + u.y*3. )*u.x )*3. )*C/36.;
  c_eq[6] = ( 1. + ( ( 1 + u.y )*u.y + ( -1 + u.x - u.y*3. )*u.x )*3. )*C/36.;
  c_eq[7] = ( 1. + ( ( -1 + u.y )*u.y + ( -1 + u.x + u.y*3. )*u.x )*3. )*C/36.;
  c_eq[8] = ( 1. + ( ( -1 + u.y )*u.y + ( 1 + u.x - u.y*3. )*u.x )*3. )*C/36.;

	for (int i=0; i< 9; i++) {
    c[i] = c[i] + omega_D * (c_eq[i]-c[i]);	
	}
}

CudaDeviceFunction void ConcentrationSourceAndEvolveHZ() {
  real_t C = getC();
  if(C <= C_saturation) {
    real_t R = k * (C_saturation - C);

    c[0] += 2 * R * 4./9.;
    c[1] += 2 * R * 1./9;
    c[2] += 2 * R * 1./9.;
    c[3] += 2 * R * 1./9.;
    c[4] += 2 * R * 1./9.;
    c[5] += 2 * R * 1./36.;
    c[6] += 2 * R * 1./36.;
    c[7] += 2 * R * 1./36.;
    c[8] += 2 * R * 1./36.;

    h_Z += 2 * R / C_solid;
  }
}

// Get functions

CudaDeviceFunction real_t getRho(){
	return <?R C(sum(f)) ?>;
}

CudaDeviceFunction real_t getC(){
	return <?R C(sum(c)) ?>;
}

CudaDeviceFunction real_t getH_Z(){
	return h_Z;
}   

CudaDeviceFunction vector_t getU(){
	real_t d = <?R C(sum(f)) ?>;
	vector_t u;

  <?R C(PV(c("u.x","u.y")), f %*% U) ?>

  <?R if ( any( DensityAll$group=="BC" ) ) { ?>
    if (!IamBOUNDARY) {   
      u.x += d*BC[0]*0.5;
      u.y += d*BC[1]*0.5;
    }
  <?R } ?>
  u.x += d*GravitationX*0.5;
  u.y += d*GravitationY*0.5;

  real_t nu = -(S2 + 1)/(6*S2 - 6) ;
    
  real_t K = d * 12. * nu / h_Z / h_Z;
    
  u.x = (u.x)/(1. + 0.5 * K) / d;
  u.y = (u.y)/(1. + 0.5 * K) / d;   

	u.z = 0.0;
	return u;
}

CudaDeviceFunction float2 Color() {
  float2 ret;
  vector_t u = getU();
  ret.x = sqrt(u.x*u.x + u.y*u.y);
  if (NodeType == NODE_Solid){
    ret.y = 0;
  } else {
    ret.y = 1;
  }
  return ret;
}